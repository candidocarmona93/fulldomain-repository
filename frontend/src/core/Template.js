/**
 * @class TemplateEngine
 * @description Handles template parsing and evaluation for reactive text nodes.
 * Replaced new Function() with safe property traversal for CSP compliance and security.
 */
export class Template {
  // This is used by ReactiveState to get the expression string, no change needed here.
  templateExpression(content) {
    // Note: The output format (using ${...}) is now purely a placeholder format, 
    // it is NOT being used in a real template literal for compilation.
    return content
      .trim()
      .replace(/{{\s*([\w.$\[\]]+?)\s*}}/g, (_, match) => `\${${match}}`)
      .replace(/{{\s*([\w.$\[\]]+?)((?:\.[\w]+\([^)]*\))+)\s*}}/g, (_, base, methods) => `\${${base}${methods}}`);
  }

  /**
   * Safely retrieves a nested property value using a dot-separated path.
   * @param {Object} obj The source object (state).
   * @param {string} path The dot-separated property path (e.g., "count" or "user.name").
   * @returns {string} The value as a string, or an empty string if not found.
   */
  getNestedValue(obj, path) {
    if (!obj || typeof obj !== 'object' || !path) return '';

    // Split only by dots that are not inside array brackets (e.g., 'a.b[0].c' -> ['a', 'b[0]', 'c'])
    const properties = path.split('.');
    let value = obj;

    for (const prop of properties) {
      if (!value || typeof value !== 'object') return '';

      // Check for array access (e.g., 'items[0]' or 'items[key]')
      const arrayMatch = prop.match(/^([\w-]+)\[(.+)\]$/);
      if (arrayMatch) {
        const arrayProp = arrayMatch[1];
        let indexOrKey = arrayMatch[2];
        
        if (value[arrayProp] && Array.isArray(value[arrayProp])) {
            // If the key in brackets is a number, treat it as an index
            if (!isNaN(parseInt(indexOrKey))) {
                indexOrKey = parseInt(indexOrKey);
            }
            value = value[arrayProp][indexOrKey];
        } else {
            return '';
        }

      } else if (prop in value) {
        value = value[prop];
      } else {
        return '';
      }
    }
    // Return the value, safely converting null/undefined/boolean/number to string
    return value !== null && value !== undefined ? String(value) : '';
  }

  /**
   * Resolves widget-targeted state access (e.g., {{@HomePage.count}})
   * This logic is extracted from the old dynamic function string.
   */
  resolveWidgetState(widget, widgetIdentifier, propertyPath) {
    try {
      if (!widget) return '';

      let targetState = null;
      let targetWidget = null;

      // 1. Try to find widget by ID (searches root-down)
      targetState = widget.getStateOf(widgetIdentifier);

      // If state is not found, we need the widget instance to get its local state
      if (!targetState) {
        // 2. Assume identifier is a Type and search ancestors (self-up)
        targetWidget = widget.findAncestorByType(widgetIdentifier);
        if (targetWidget) {
          targetState = targetWidget.getState(); // getState() is local state
        }
      }

      if (!targetState) {
        // 3. If still not found, search all descendants (root-down)
        const root = widget.getRootWidget();
        if (root) {
          targetWidget = root.findDescendantByType(widgetIdentifier);
          if (targetWidget) {
            targetState = targetWidget.getState();
          }
        }
      }

      if (!targetState) {
        return '';
      }

      // Safely access the nested property on the found state object
      return this.getNestedValue(targetState, propertyPath);

    } catch (error) {
      console.warn('Widget state access error:', error);
      return '';
    }
  }


  /**
   * Returns a renderer function that performs safe string replacement.
   * This is the core replacement for new Function().
   */
  evaluateTemplate(content, state, widget) {
    // The expression generated by templateExpression is passed as 'content' here.
    
    // Return the actual rendering function. This is what ReactiveState will call.
    return (store, widgetInstance) => {
      let output = content;

      // 1. Replace all simple state properties: ${prop} (e.g., ${count})
      output = output.replace(/\$\{(?!___getWidgetState___)([\w.]+)\}/g, (match, path) => {
        // Use the safe property accessor on the local store
        const value = this.getNestedValue(store, path);
        return value;
      });

      // 2. Replace all widget-targeted properties (which are already wrapped in ___getWidgetState___ calls by templateExpression)
      // Example: ${___getWidgetState___('widgetId', 'property.path')}
      output = output.replace(/\$\{\s*___getWidgetState___\s*\(['"]([^'"]+)['"]\s*,\s*['"]([^'"]+)['"]\s*\)\s*\}/g, (match, widgetIdentifier, propertyPath) => {
        // Use the safe resolver
        const value = this.resolveWidgetState(widgetInstance, widgetIdentifier, propertyPath);
        return value;
      });

      // The dynamic compilation of methods like ${prop.toUpperCase()} is not easily and safely supported 
      // by this pure traversal method. For that, you would need a secure sandbox (like web workers) 
      // or a full AST parser, but for simple property access, this is the solution.

      return output;
    };
  }
}